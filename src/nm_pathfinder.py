from heapq import heappop, heappushfrom math import sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    visited = []    processed = []    source = 0;    destination = 0;    def get_cords_from_box(box):        x1, x2, y1, y2 = box;        midX = 0;        midY = 0;        if box == source:            midX = source_point[0]            midY = source_point[1]        elif box == destination:            #print("changing destination cords")            midX = destination_point[0]            midY = destination_point[1]        else:            midX = x1 + ((x2 - x1) / 2)            midY = y1 + ((y2 - y1) / 2)        return (midX, midY)    def dist_between(cord1, cord2):        square = ((cord1[0] - cord2[0]) ** 2) + ((cord1[1] - cord2[1]) ** 2)        distance_between = sqrt(square)        return distance_between    # Find source and destination boxes    detail_points = {}    for box in mesh["boxes"]:        detail_points[box] = get_cords_from_box(box)        if (inside_box(source_point, box)):            source = box;        if (inside_box(destination_point, box)):            destination = box;    #error checking    if(source == 0 or destination == 0):        print("Clicked in area not inside any boxes.")        return [] ,[]    #Create Queue and push source onto it    queue = []    heappush(queue,(0,source,"seeking_destination"))    heappush(queue, (0, destination, "seeking_source"))    #Dictionary to keep track of the parents of each box    parents_forward = {}    parents_backward = {}    parents_forward[source] = None    parents_backward[destination] = None    #Dictionary to keep track of the costs of each box    cost_so_far_forward = dict();    cost_so_far_backward = dict();    cost_so_far_forward[source] = 0    cost_so_far_backward[destination] = 0    #Dictionary to keep track of the total distance traveled to reach each box    dist_traveled_forward = {}    dist_traveled_backward = {}    dist_traveled_forward[source] = 0    dist_traveled_backward[destination] = 0;    visited.append(source)    starting_node = 0;    broke_from = 0;    box_not_found = True;    while len(queue) > 0:        current = heappop(queue)        _1, curr_box, heading_to = current;        #print("Score:", _1, "\n",curr_box,"\n-----------------------------")        #x1, x2, y1, y2 = curr_cords;        visited.append(curr_box)        if heading_to == "seeking_destination" and curr_box == destination:            starting_node = curr_box            starting_node2 = destination            #print("Destination seeker found destination")            broke_from == "seeking_destination"            box_not_found = False;            break        elif heading_to == "seeking_source" and curr_box == source:            #print("source seeker found source")            starting_node = curr_box            starting_node2 = source            broke_from == "seeking_source"            box_not_found = False;            break        if heading_to == "seeking_destination" and curr_box in parents_backward:            #print("destination seeker found box in backwards search")            starting_node = curr_box            starting_node2 = parents_backward[curr_box]            broke_from == "seeking_destination"            box_not_found = False;            break;        if heading_to == "seeking_source" and curr_box in parents_forward:            #print("source seeker found box in forwards search")            starting_node = parents_forward[curr_box]            starting_node2 = curr_box            broke_from == "seeking_source"            box_not_found = False;            break;        midX, midY = get_cords_from_box(curr_box)        for next in mesh["adj"][curr_box]:            if heading_to == "seeking_destination":                #print("1")                goal = destination_point                dist = dist_traveled_forward[curr_box]            else: #seeking_source                #print("2")                goal = source_point                dist = dist_traveled_backward[curr_box]              #distance traveled    +   distance between current box and next   +   distance between next box and its respective goal            new_cost = dist + dist_between(get_cords_from_box(next),(midX,midY)) + dist_between(get_cords_from_box(next),goal)            if(heading_to == "seeking_destination"):                if next not in cost_so_far_forward or new_cost < cost_so_far_forward[next]:                    cost_so_far_forward[next] = new_cost                    dist_traveled_forward[next] = dist_traveled_forward[curr_box] + dist_between(get_cords_from_box(next),(midX,midY))                    heappush(queue,(new_cost, next,heading_to))                    parents_forward[next] = curr_box            elif heading_to == "seeking_source":                if next not in cost_so_far_backward or new_cost < cost_so_far_backward[next]:                    cost_so_far_backward[next] = new_cost                    dist_traveled_backward[next] = dist_traveled_backward[curr_box] + dist_between(get_cords_from_box(next),(midX,midY))                    heappush(queue,(new_cost, next,heading_to))                    parents_backward[next] = curr_box    if box_not_found:        #Path not available so just return identified source and destination boxes        print("No path available!")        l1 = []        l1.append(source)        l1.append(destination)        return [], l1    #Setting up variables to draw the path    curr_parent = parents_forward[starting_node]    curr_point = get_cords_from_box(starting_node)    path_boxes = [];    while curr_parent != None:        x1,x2,y1,y2 = curr_parent        #Constrain cord to the next box to make sure it only makes legal moves        next_cord = (constrain(curr_point[0], x1, x2), constrain(curr_point[1], y1, y2))        #Append to tracking variables        path.append(next_cord)        path_boxes.append(curr_parent)        #Get next box        curr_point = next_cord        curr_parent = parents_forward[curr_parent]    #curr_parent = parents_backward[starting_node2]    #curr_point = get_cords_from_box(starting_node2)    #Include link between the two starting nodes to ensure legal crossing between the two paths    curr_parent = starting_node2    curr_point = get_cords_from_box(starting_node)    while curr_parent != None:        x1, x2, y1, y2 = curr_parent        # Constrain cord to the next box to make sure it only makes legal moves        next_cord = (constrain(curr_point[0], x1, x2), constrain(curr_point[1], y1, y2))        # Append to tracking variables        path.insert(0,next_cord)        path_boxes.append(curr_parent)        # Get next box        curr_point = next_cord        curr_parent = parents_backward[curr_parent]    #Add destination and starting box    #path_boxes.append(destination)    #path_boxes.append(source)    #Add initial points to path    #print(path)    path.append(source_point)    path.insert(0,destination_point)    temp_cords = path[-2]    #purposeful -1 to place behind the last value    path.insert(-1,(constrain(temp_cords[0], source[0], source[1]), constrain(temp_cords[1], source[2], source[3])))    boxes["boxes"] = visited    #return path and the boxes visited    return path, boxes["boxes"]def inside_box(point,box):    x1, x2, y1, y2 = box;    #print("\n", point[0])    if(x1 <= point[0] and point[0] <= x2):        if(y1 <= point[1] and point[1] <= y2):            return True;    return Falsedef constrain(val, min, max):    if(val < min):        return min    if(val > max):        return max    return val